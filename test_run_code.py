import numpy as np
import pytest

import utils
from run_code import exec_and_run, execute_transform

CODE_1 = """
def transform(initial):
    # check we receive np.ndarray always
    assert isinstance(initial, np.ndarray), 'Expecting np.ndarray'
    return initial
"""

CODE_2 = """
import numpy as np # confirm double-importing is ok
def transform(initial):
    return initial
"""

# this solves 9565186b, it was mostly generated by a model
CODE_3 = """
def transform(initial):
    import numpy as np
    initial = np.array(initial)
    assert initial.shape == (3,3)

    # Find the frequency of each value in "initial"
    freq_dict = {}
    for i in range(3):
        for j in range(3):
            if initial[i][j] not in freq_dict:
                freq_dict[initial[i][j]] = 1
            else:
                freq_dict[initial[i][j]] += 1

    # Find the most frequent value, least frequent values, and middle-frequency values
    sorted_freq = sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)
    most_frequent_value = sorted_freq[0][0]
    #least_frequent_values = [x[0] for x in sorted_freq[-2:]]
    #middle_frequency_values = [x[0] for x in sorted_freq[1:-2]]

    # Replace the least frequent values with a new value
    #new_value = max(freq_dict) + 1
    new_value = 5
    final = initial.copy()
    for i in range(3):
        for j in range(3):
            if final[i][j] != most_frequent_value:
                final[i][j] = new_value

    assert final.shape == (3,3)
    return final
    """

CODE_3_tolist = """
def transform(initial):
    import numpy as np
    initial = np.array(initial)
    assert initial.shape == (3,3)

    # Find the frequency of each value in "initial"
    freq_dict = {}
    for i in range(3):
        for j in range(3):
            if initial[i][j] not in freq_dict:
                freq_dict[initial[i][j]] = 1
            else:
                freq_dict[initial[i][j]] += 1

    # Find the most frequent value
    sorted_freq = sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)
    most_frequent_value = sorted_freq[0][0]

    # Replace the least frequent values with a new value
    #new_value = max(freq_dict) + 1 # mistake
    new_value = 5
    final = initial.copy()
    for i in range(3):
        for j in range(3):
            if final[i][j] != most_frequent_value:
                final[i][j] = new_value

    assert final.shape == (3,3)
    return final.tolist()
    """


# this solves 9565186b, it was generated by deepseek
CODE_3_deepseek = """
import numpy as np

def transform(initial):
    assert isinstance(initial, np.ndarray)
    
    # Flatten the array to count frequencies
    flat = initial.flatten()
    unique, counts = np.unique(flat, return_counts=True)
    
    # Find the most frequent number(s)
    max_count = np.max(counts)
    most_frequent = unique[counts == max_count]
    
    # Create a mask for numbers that are not most frequent
    mask = ~np.isin(initial, most_frequent)
    
    # Apply the transformation
    final = initial.copy()
    final[mask] = 5
    
    assert isinstance(final, np.ndarray)
    return final

"""

# THIS FIXTURE IS NOT TIED IN
# Generated using Llama Scout to solve 0d3d703e (baseline prompt, no hints)
CODE_4 = """
import numpy as np

def transform(initial):
    assert isinstance(initial, np.ndarray)
    # Define the mapping
    digit_mapping = {
        0: 0, 1: 5, 2: 6, 3: 4, 4: 3,
        5: 1, 6: 2, 7: 7, 8: 9, 9: 8
    }
    
    # Apply the mapping to each element in the grid
    final = np.vectorize(digit_mapping.get)(initial)
    
    assert isinstance(final, np.ndarray)
    return final
"""

# 2024-10 this is a bad direction to go directly, rather than via
# joblib, as this calls exec which populates the namespace!
CODE_BADLY_NAMED_FN = """
def somethingelse():
    pass"""
CODE_WRONG_NOARGS = """
def transform():
    pass"""
CODE_WRONG_TWOARGS = """
def transform(initial, another):
    pass"""
CODE_GOOD_RAISES_EXCEPTION = """
def transform(initial):
    raise Exception("bad")
    pass"""

CODE_GOOD_RETURNS_NON2DARRAY_1DARR = """
def transform(initial):
    return np.array([1, 2, 3])"""

CODE_GOOD_RETURNS_NON2DARRAY_SCALAR = """
def transform(initial):
    return np.float(1)"""

# Additional test cases
CODE_SYNTAX_ERROR = """
def transform(initial):
    return initial +
"""

CODE_INFINITE_LOOP = """
def transform(initial):
    while True:
        pass
    return initial
"""

CODE_RETURNS_NONE = """
def transform(initial):
    # Forgot to return anything
    pass
"""

CODE_RETURNS_WRONG_SHAPE = """
def transform(initial):
    # Return different shape than input
    return np.zeros((5, 5))
"""

CODE_MODIFIES_INPUT = """
def transform(initial):
    # Modifies input in place (bad practice but should still work)
    initial[0, 0] = 999
    return initial
"""

CODE_USES_PRINT = """
def transform(initial):
    print("Debug output")
    print(f"Shape: {initial.shape}")
    return initial
"""

CODE_IMPORTS_FORBIDDEN = """
def transform(initial):
    import os
    os.system("echo 'hello'")  # Potentially dangerous
    return initial
"""

CODE_MEMORY_HOG = """
def transform(initial):
    # Try to allocate huge array
    huge = np.zeros((10000, 10000, 10000))
    return initial
"""

CODE_DIFFERENT_DTYPES = """
def transform(initial):
    # Return float array instead of int
    return initial.astype(np.float64)
"""

CODE_3D_ARRAY = """
def transform(initial):
    # Return 3D array
    return np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
"""

CODE_EMPTY_ARRAY = """
def transform(initial):
    # Return empty array
    return np.array([])
"""


def assert_no_transform_pollution():
    assert "transform" not in dir()
    assert "transform" not in globals()


def test_exec_and_run():
    initial = [[1, 2], [3, 3]]
    code = ""
    assert_no_transform_pollution()
    with pytest.raises(NameError):
        exec_and_run(code, initial)


def test_execute_transform_on_bad_fn():
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    assert_no_transform_pollution()

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_BADLY_NAMED_FN, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert "name 'transform' is not defined" in exception_message
    assert len(execution_outcomes) == 0
    # print(exception_message)

    # TODO how to capture the fact that we got a name error which is useful?
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_WRONG_TWOARGS, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert len(execution_outcomes) == 0
    assert "transform() missing 1 required" in exception_message

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_WRONG_NOARGS, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert len(execution_outcomes) == 0
    assert "transform() takes 0 positional" in exception_message

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_GOOD_RAISES_EXCEPTION, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert len(execution_outcomes) == 0
    assert "<class 'Exception'>" in exception_message


def test_execute_transform():
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]

    rr, execution_outcomes, exception_message = execute_transform(CODE_1, problems)
    print(rr)
    assert rr.code_did_execute is True
    assert len(execution_outcomes) == 4
    # print(execution_outcomes)
    for eo in execution_outcomes:
        assert not eo.was_correct
        assert np.array(eo.initial).shape == (3, 3)

    rr, execution_outcomes, exception_message = execute_transform(CODE_2, problems)
    print(rr)
    assert rr.code_did_execute is True
    assert len(execution_outcomes) == 4


def test_execute_transform2():
    """check we solve this challenge with (mostly llm) code sample"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]

    for code_block in [CODE_3, CODE_3_deepseek]:
        rr, execution_outcomes, exception_message = execute_transform(
            code_block, problems
        )
        print(execution_outcomes)
        print(rr)
        assert rr.code_did_execute is True
        assert rr.code_ran_on_all_inputs is True
        assert rr.transform_ran_and_matched_for_all_inputs is True
        assert rr.transform_ran_and_matched_at_least_once is True
        assert rr.transform_ran_and_matched_score == 4

        # CODE_3 runs and should make a correct output
        for eo in execution_outcomes:
            assert eo.was_correct
            assert np.array(eo.initial).shape == (3, 3)

        # this variant returns tolist not np array, whilst it should
        # run it should also fail to be scored as only ndarray is
        # expected as the returned type
        rr, execution_outcomes, exception_message = execute_transform(
            CODE_3_tolist, problems
        )
        print(rr)
        assert rr.code_did_execute is True
        assert rr.transform_ran_and_matched_score == 0


def test_execute_transform3():
    problem_train_test = utils.get_examples("0d3d703e")
    problems = problem_train_test["train"]

    for code_block in [CODE_4]:
        rr, execution_outcomes, exception_message = execute_transform(
            code_block, problems
        )
        print(execution_outcomes)
        print(rr)
        assert rr.code_did_execute is True
        assert rr.code_ran_on_all_inputs is True
        assert rr.transform_ran_and_matched_for_all_inputs is True
        assert rr.transform_ran_and_matched_at_least_once is True
        assert rr.transform_ran_and_matched_score == 4


def test_execute_transform_weird_results():
    """check for valid code that returns a non 2d array"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_GOOD_RETURNS_NON2DARRAY_1DARR, problems
    )
    print(execution_outcomes)
    print(rr)
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert rr.transform_ran_and_matched_at_least_once is False
    assert rr.transform_ran_and_matched_score == 0


def test_syntax_error():
    """Test handling of syntax errors in code"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_SYNTAX_ERROR, problems
    )
    assert rr.code_did_execute is False
    assert rr.code_ran_on_all_inputs is False
    assert "SyntaxError" in exception_message
    assert len(execution_outcomes) == 0


def test_infinite_loop_timeout():
    """Test that infinite loops are caught by timeout"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_INFINITE_LOOP, problems
    )
    # The code should execute but timeout when running
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is False
    assert len(execution_outcomes) == 0


def test_returns_none():
    """Test handling when transform returns None"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_RETURNS_NONE, problems
    )
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is False
    assert "Expecting `transform` to return a numpy array" in exception_message


def test_returns_wrong_shape():
    """Test when transform returns array of wrong shape"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_RETURNS_WRONG_SHAPE, problems
    )
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    # Should run but not match
    for eo in execution_outcomes:
        assert not eo.was_correct


def test_modifies_input():
    """Test code that modifies input array (should still work)"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_MODIFIES_INPUT, problems
    )
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is True
    # Won't match because we're modifying the array
    assert rr.transform_ran_and_matched_for_all_inputs is False


def test_code_with_print():
    """Test that code with print statements still works"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_USES_PRINT, problems
    )
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is True
    # Should work but not match (returns input unchanged)
    assert len(execution_outcomes) == 4


def test_different_dtypes():
    """Test when transform returns different dtype"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_DIFFERENT_DTYPES, problems
    )
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is True
    # May or may not match depending on how equality is checked
    assert len(execution_outcomes) == 4


def test_returns_3d_array():
    """Test when transform returns 3D array instead of 2D"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_3D_ARRAY, problems
    )
    assert rr.code_did_execute is True
    # Should fail because it's not 2D
    assert rr.transform_ran_and_matched_for_all_inputs is False


def test_returns_empty_array():
    """Test when transform returns empty array"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_EMPTY_ARRAY, problems
    )
    assert rr.code_did_execute is True
    # Should fail because empty array doesn't match expected output
    assert rr.transform_ran_and_matched_for_all_inputs is False


def test_scalar_return():
    """Test handling when transform returns a scalar"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_GOOD_RETURNS_NON2DARRAY_SCALAR, problems
    )
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is False
    assert "Expecting `transform` to return a numpy array" in exception_message


def test_memory_intensive_code():
    """Test code that tries to allocate too much memory"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"][:1]  # Just use one problem to be faster
    
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_MEMORY_HOG, problems
    )
    assert rr.code_did_execute is True
    # Should fail with MemoryError or similar
    assert rr.code_ran_on_all_inputs is False


def test_multiple_problems_partial_success():
    """Test when code works for some problems but not others"""
    # Create a custom code that will fail on certain inputs
    code_partial = """
def transform(initial):
    # This will fail if the array contains values > 5
    assert initial.max() <= 5, "Values too large"
    return initial
"""
    
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    
    rr, execution_outcomes, exception_message = execute_transform(
        code_partial, problems
    )
    assert rr.code_did_execute is True
    # May or may not run on all inputs depending on the data
    # But definitely won't match all
    assert rr.transform_ran_and_matched_for_all_inputs is False
